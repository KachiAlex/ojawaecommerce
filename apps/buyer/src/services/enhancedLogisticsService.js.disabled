import { collection, query, where, getDocs } from 'firebase/firestore';
import { db } from '../firebase/config';

// Google Maps API Key
const GOOGLE_MAPS_API_KEY = 'AIzaSyCw_5hgEojEOW1hAIewyb4TkyHTN2od-Yk';

class EnhancedLogisticsService {
  /**
   * Geocode an address to get coordinates and formatted address
   */
  async geocodeAddress(addressObj) {
    try {
      const addressString = `${addressObj.street}, ${addressObj.city}, ${addressObj.state}, ${addressObj.country}`;
      
      // Add timeout to prevent hanging requests
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000);
      
      try {
        // Use CORS proxy service for Google Maps API calls
        const proxyUrl = 'https://cors-anywhere.herokuapp.com/';
        const targetUrl = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(addressString)}&key=${GOOGLE_MAPS_API_KEY}`;
        
        const response = await fetch(proxyUrl + targetUrl, {
          signal: controller.signal,
          headers: {
            'X-Requested-With': 'XMLHttpRequest'
          }
        });
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        if (data.status === 'OK' && data.results.length > 0) {
          const result = data.results[0];
          return {
            success: true,
            coordinates: result.geometry.location,
            formattedAddress: result.formatted_address,
            addressComponents: result.address_components
          };
        }
        
        return { success: false, error: 'Address not found' };
      } catch (fetchError) {
        clearTimeout(timeoutId);
        throw fetchError;
      }
    } catch (error) {
      console.warn('Geocoding failed, using fallback:', error.message);
      // Return fallback coordinates for Nigeria
      return {
        success: true,
        coordinates: { lat: 9.0765, lng: 7.3986 }, // Abuja coordinates as fallback
        formattedAddress: addressString,
        addressComponents: []
      };
    }
  }

  /**
   * Calculate distance between two coordinates using Google Maps Distance Matrix API
   */
  async calculateDistance(origin, destination) {
    try {
      const originString = `${origin.street}, ${origin.city}, ${origin.state}, ${origin.country}`;
      const destinationString = `${destination.street}, ${destination.city}, ${destination.state}, ${destination.country}`;
      
      // Try Google Maps Distance Matrix API (client-side)
      try {
        // Check if Google Maps is loaded
        if (window.google && window.google.maps && window.google.maps.DistanceMatrixService) {
          console.log('üó∫Ô∏è Using Google Maps Distance Matrix API for accurate distance calculation...');
          
          const service = new google.maps.DistanceMatrixService();
          
          // Add timeout to prevent hanging
          const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error('Distance Matrix API timeout')), 8000);
          });
          
          // Wrap in promise to use async/await
          const distancePromise = new Promise((resolve, reject) => {
            service.getDistanceMatrix(
              {
                origins: [originString],
                destinations: [destinationString],
                travelMode: google.maps.TravelMode.DRIVING,
                unitSystem: google.maps.UnitSystem.METRIC,
                avoidHighways: false,
                avoidTolls: false
              },
              (response, status) => {
                if (status === 'OK' && response.rows[0]?.elements[0]?.status === 'OK') {
                  resolve(response);
                } else if (status === 'REQUEST_DENIED') {
                  console.warn('‚ö†Ô∏è Distance Matrix API not enabled. Enable it in Google Cloud Console:');
                  console.warn('   1. Go to https://console.cloud.google.com/apis/library/distance-matrix-backend.googleapis.com');
                  console.warn('   2. Enable "Distance Matrix API"');
                  console.warn('   3. Ensure billing is enabled for your project');
                  reject(new Error(`Distance Matrix API not enabled: ${status}`));
                } else {
                  reject(new Error(`Distance Matrix failed: ${status}`));
                }
              }
            );
          });
          
          const result = await Promise.race([distancePromise, timeoutPromise]);
          
          // Extract distance data from response
          const element = result.rows[0].elements[0];
          console.log('‚úÖ Google Maps Distance Matrix result:', {
            distance: element.distance.text,
            duration: element.duration.text
          });
          
          return {
            success: true,
            distanceInMeters: element.distance.value,
            distanceInKm: (element.distance.value / 1000).toFixed(2),
            distanceText: element.distance.text,
            durationInSeconds: element.duration.value,
            durationText: element.duration.text
          };
        } else {
          console.log('‚ö†Ô∏è Google Maps not loaded, using fallback calculation');
        }
      } catch (error) {
        console.warn('‚ùå Google Maps Distance Matrix failed, using fallback calculation:', error.message);
      }
      
      // Fallback: Use approximate distance calculation based on cities
      console.log('üìä Using fallback distance calculation (Google Maps API not available)');
      const originCity = origin.city?.toLowerCase() || '';
      const destinationCity = destination.city?.toLowerCase() || '';
      const originState = origin.state?.toLowerCase() || '';
      const destinationState = destination.state?.toLowerCase() || '';
      
      // Enhanced Lagos metropolitan area detection
      const lagosMetroAreas = ['lagos', 'ikeja', 'surulere', 'yaba', 'ikoyi', 'vi', 'lekki', 
                               'ajah', 'festac', 'apapa', 'mushin', 'oshodi', 'shomolu', 
                               'bariga', 'ikorodu', 'badagry', 'epe', 'alimosho', 'ifako-ijaiye',
                               'dopemu', 'agege', 'ojota', 'ketu', 'mile 2', 'mile 12'];
      
      const isOriginLagosMetro = originState === 'lagos' || lagosMetroAreas.includes(originCity);
      const isDestLagosMetro = destinationState === 'lagos' || lagosMetroAreas.includes(destinationCity);
      
      // If both in Lagos metropolitan area
      if (isOriginLagosMetro && isDestLagosMetro) {
        // Estimate based on common Lagos distances
        let estimatedKm = 12; // Default medium intracity distance
        let estimatedMins = 35; // Default Lagos traffic time
        
        // Same exact city/area - short distance
        if (originCity === destinationCity) {
          estimatedKm = 5;
          estimatedMins = 15;
        }
        // Common intracity routes - adjust based on typical patterns
        else if ((originCity === 'ikeja' && destinationCity === 'lekki') || 
                 (originCity === 'lekki' && destinationCity === 'ikeja')) {
          estimatedKm = 25;
          estimatedMins = 60;
        }
        else if ((originCity === 'surulere' && destinationCity === 'vi') || 
                 (originCity === 'vi' && destinationCity === 'surulere')) {
          estimatedKm = 15;
          estimatedMins = 40;
        }
        
        console.log(`üìä Estimated intracity distance: ${estimatedKm} km, ${estimatedMins} mins`);
        
        return {
          success: true,
          distanceInMeters: estimatedKm * 1000,
          distanceInKm: estimatedKm.toFixed(2),
          distanceText: `${estimatedKm} km (estimated)`,
          durationInSeconds: estimatedMins * 60,
          durationText: `${estimatedMins} mins (estimated)`,
          isEstimate: true
        };
      }
      
      // If same state but different cities (intercity within state)
      if (originState === destinationState) {
        const estimatedKm = 80;
        const estimatedHours = 1.5;
        
        console.log(`üìä Estimated intercity distance: ${estimatedKm} km, ${estimatedHours} hours`);
        
        return {
          success: true,
          distanceInMeters: estimatedKm * 1000,
          distanceInKm: estimatedKm.toFixed(2),
          distanceText: `${estimatedKm} km (estimated)`,
          durationInSeconds: estimatedHours * 3600,
          durationText: `${estimatedHours} hours (estimated)`,
          isEstimate: true
        };
      }
      
      // If different states (long intercity)
      const estimatedKm = 350;
      const estimatedHours = 5;
      
      console.log(`üìä Estimated interstate distance: ${estimatedKm} km, ${estimatedHours} hours`);
      
      return {
        success: true,
        distanceInMeters: estimatedKm * 1000,
        distanceInKm: estimatedKm.toFixed(2),
        distanceText: `${estimatedKm} km (estimated)`,
        durationInSeconds: estimatedHours * 3600,
        durationText: `${estimatedHours} hours (estimated)`,
        isEstimate: true
      };
    } catch (error) {
      console.error('Distance calculation error:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Determine route category based on addresses
   */
  categorizeRoute(vendorAddress, buyerAddress) {
    // Validate addresses are objects with required fields
    if (!vendorAddress || !buyerAddress) {
      return null;
    }

    // Normalize for comparison - handle both string and object types
    const vendorCity = (typeof vendorAddress.city === 'string' ? vendorAddress.city : '')?.toLowerCase().trim();
    const vendorState = (typeof vendorAddress.state === 'string' ? vendorAddress.state : '')?.toLowerCase().trim();
    const vendorCountry = (typeof vendorAddress.country === 'string' ? vendorAddress.country : 'nigeria')?.toLowerCase().trim();
    
    const buyerCity = (typeof buyerAddress.city === 'string' ? buyerAddress.city : '')?.toLowerCase().trim();
    const buyerState = (typeof buyerAddress.state === 'string' ? buyerAddress.state : '')?.toLowerCase().trim();
    const buyerCountry = (typeof buyerAddress.country === 'string' ? buyerAddress.country : 'nigeria')?.toLowerCase().trim();

    // Check if we have minimum required data
    if (!vendorCity || !buyerCity) {
      return null;
    }

    // International: Different countries
    if (vendorCountry !== buyerCountry) {
      return {
        category: 'international',
        from: `${vendorAddress.city}, ${vendorAddress.country}`,
        to: `${buyerAddress.city}, ${buyerAddress.country}`,
        description: 'International delivery (cross-border)'
      };
    }

    // Special case: Lagos state - treat all cities within Lagos as intracity
    if (vendorState === 'lagos' && buyerState === 'lagos') {
      return {
        category: 'intracity',
        from: `${vendorAddress.city}, Lagos`,
        to: `${buyerAddress.city}, Lagos`,
        description: 'Intracity delivery (within Lagos metropolitan area)'
      };
    }

    // Intercity: Same country, different cities
    if (vendorCity !== buyerCity) {
      return {
        category: 'intercity',
        from: `${vendorAddress.city}, ${vendorAddress.state}`,
        to: `${buyerAddress.city}, ${buyerAddress.state}`,
        description: 'Intercity delivery (between cities)'
      };
    }

    // Intracity: Same city
    return {
      category: 'intracity',
      from: vendorAddress.city,
      to: buyerAddress.city,
      description: 'Intracity delivery (within city)'
    };
  }

  /**
   * Find logistics partners with matching active routes
   */
  async findMatchingLogisticsPartners(routeCategory, vendorAddress, buyerAddress) {
    try {
      console.log('üîç Finding logistics partners for route:', routeCategory);
      console.log('üîç Vendor address:', vendorAddress);
      console.log('üîç Buyer address:', buyerAddress);
      
      const logisticsProfilesRef = collection(db, 'logistics_profiles');
      let matchingPartners = [];

      if (routeCategory.category === 'intracity') {
        // For intracity routes, we need to find partners who have the buyer's state in their serviceAreas
        // serviceAreas is an array of objects: [{country: "Nigeria", state: "Lagos", id: "nigeria-lagos"}]
        
        console.log('üîç Looking for intracity partners for state:', buyerAddress.state);
        
        // Get all approved and pending logistics profiles first, then filter by service areas
        // (Firestore doesn't support complex queries on array objects)
        // Note: Including 'pending' status for now so partners can be used immediately
        const q = query(
          logisticsProfilesRef,
          where('status', 'in', ['approved', 'pending'])
        );
        
        const snapshot = await getDocs(q);
        console.log('üîç Found', snapshot.docs.length, 'approved logistics profiles');
        
        matchingPartners = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        })).filter(partner => {
          // Check if partner has the buyer's state in their service areas
          if (!partner.serviceAreas || !Array.isArray(partner.serviceAreas)) {
            console.log('üîç Partner has no service areas:', partner.companyName);
            return false;
          }
          
          const hasServiceArea = partner.serviceAreas.some(area => {
            const stateMatch = area.state?.toLowerCase() === buyerAddress.state?.toLowerCase();
            console.log('üîç Checking service area:', area.state, 'vs', buyerAddress.state, '=', stateMatch);
            return stateMatch;
          });
          
          if (hasServiceArea) {
            console.log('‚úÖ Found matching partner:', partner.companyName, 'for state:', buyerAddress.state);
          }
          
          return hasServiceArea;
        });
        
        console.log('üîç Final matching partners for intracity:', matchingPartners.length, matchingPartners);
      } else if (routeCategory.category === 'intercity') {
        // Find partners with this specific intercity route
        const q = query(
          logisticsProfilesRef,
          where('status', 'in', ['approved', 'pending']),
          where('routeType', '==', 'intercity'),
          where('from', '==', vendorAddress.city),
          where('to', '==', buyerAddress.city)
        );
        
        const snapshot = await getDocs(q);
        matchingPartners = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        }));

        // Also try reverse route
        const qReverse = query(
          logisticsProfilesRef,
          where('status', 'in', ['approved', 'pending']),
          where('routeType', '==', 'intercity'),
          where('from', '==', buyerAddress.city),
          where('to', '==', vendorAddress.city)
        );
        
        const snapshotReverse = await getDocs(qReverse);
        const reversePartners = snapshotReverse.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        }));
        
        matchingPartners = [...matchingPartners, ...reversePartners];
      } else if (routeCategory.category === 'international') {
        // Find partners with international routes covering these countries
        const q = query(
          logisticsProfilesRef,
          where('status', 'in', ['approved', 'pending']),
          where('routeType', '==', 'international'),
          where('fromCountry', '==', vendorAddress.country),
          where('toCountry', '==', buyerAddress.country)
        );
        
        const snapshot = await getDocs(q);
        matchingPartners = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        }));
      }

      return matchingPartners;
    } catch (error) {
      console.error('Error finding matching partners:', error);
      return [];
    }
  }

  /**
   * Calculate pricing based on partner rates and distance
   */
  calculatePricing(partners, distanceInKm, routeCategory) {
    if (partners.length === 0) {
      // Use platform default pricing
      const ratePerKm = 500;
      let basePrice = distanceInKm * ratePerKm;
      
      // Apply min/max caps based on category
      if (routeCategory.category === 'intracity') {
        basePrice = Math.max(2000, Math.min(basePrice, 10000));
      } else if (routeCategory.category === 'intercity') {
        basePrice = Math.max(5000, Math.min(basePrice, 20000));
      } else {
        basePrice = Math.max(15000, basePrice); // No max for international
      }
      
      return {
        price: Math.round(basePrice),
        usingPlatformDefault: true,
        breakdown: {
          baseCalculation: `${distanceInKm}km √ó ‚Ç¶${ratePerKm}/km = ‚Ç¶${Math.round(distanceInKm * ratePerKm)}`,
          appliedRule: routeCategory.category === 'intracity' 
            ? 'Min ‚Ç¶2,000, Max ‚Ç¶10,000'
            : routeCategory.category === 'intercity'
            ? 'Min ‚Ç¶5,000, Max ‚Ç¶20,000'
            : 'Min ‚Ç¶15,000'
        }
      };
    }

    // Calculate price for each partner
    const partnersWithPricing = partners.map(partner => {
      const ratePerKm = partner.ratePerKm || 500;
      let calculatedPrice = distanceInKm * ratePerKm;
      
      // Use partner's suggested price if available
      if (partner.suggestedPrice) {
        calculatedPrice = partner.suggestedPrice;
      }
      
      return {
        ...partner,
        calculatedPrice: Math.round(calculatedPrice),
        ratePerKm
      };
    });

    // Sort by price (cheapest first)
    partnersWithPricing.sort((a, b) => a.calculatedPrice - b.calculatedPrice);
    
    const cheapest = partnersWithPricing[0];
    
    return {
      price: cheapest.calculatedPrice,
      selectedPartner: cheapest,
      availablePartners: partnersWithPricing,
      usingPlatformDefault: false,
      breakdown: {
        baseCalculation: `${distanceInKm}km √ó ‚Ç¶${cheapest.ratePerKm}/km = ‚Ç¶${Math.round(distanceInKm * cheapest.ratePerKm)}`,
        appliedRule: `Partner: ${cheapest.companyName || 'Logistics Partner'}`
      }
    };
  }

  /**
   * Main function to calculate delivery with all steps
   */
  async calculateCompleteDelivery(vendorAddress, buyerAddress) {
    try {
      // Validate inputs
      if (!vendorAddress || !buyerAddress || 
          !vendorAddress.city || !buyerAddress.city) {
        return {
          success: false,
          error: 'Incomplete address information'
        };
      }

      // Step 1: Categorize route
      const routeCategory = this.categorizeRoute(vendorAddress, buyerAddress);
      
      if (!routeCategory) {
        return {
          success: false,
          error: 'Could not categorize route'
        };
      }
      
      // Step 2: Calculate distance using Google Maps
      const distanceResult = await this.calculateDistance(vendorAddress, buyerAddress);
      
      if (!distanceResult.success) {
        return {
          success: false,
          error: 'Could not calculate distance',
          ...routeCategory
        };
      }
      
      // Step 3: Find matching logistics partners
      console.log('üîç Finding matching logistics partners...');
      const partners = await this.findMatchingLogisticsPartners(routeCategory, vendorAddress, buyerAddress);
      console.log('üîç Available partners:', partners.length, 'found');
      console.log('üîç Partner details:', partners);
      
      // Step 4: Calculate pricing
      const pricing = this.calculatePricing(partners, parseFloat(distanceResult.distanceInKm), routeCategory);
      console.log('üí∞ Pricing result:', pricing);
      
      return {
        success: true,
        ...routeCategory,
        distance: parseFloat(distanceResult.distanceInKm),
        distanceText: distanceResult.distanceText,
        duration: distanceResult.durationText,
        ...pricing
      };
    } catch (error) {
      console.error('Complete delivery calculation error:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }
}

export default new EnhancedLogisticsService();

